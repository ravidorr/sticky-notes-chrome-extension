/**
 * Site Build Script
 * 
 * Combines HTML partials with page templates to generate the final site files.
 * Also bundles CSS imports and minifies JavaScript and CSS for better performance.
 * 
 * Usage: node scripts/build-site.js
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { minify } from 'terser';
import CleanCSS from 'clean-css';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SITE_DIR = path.join(__dirname, '..', 'site');
const PARTIALS_DIR = path.join(SITE_DIR, 'partials');
const TEMPLATES_DIR = path.join(SITE_DIR, 'templates');
const CSS_DIR = path.join(SITE_DIR, 'css');
const JS_DIR = path.join(SITE_DIR, 'js');

// Cache for minified CSS content (used for inlining)
let minifiedCssCache = null;
let minifiedCriticalCssCache = null;

/**
 * Read a file and return its contents
 */
function readFile(filePath) {
    try {
        return fs.readFileSync(filePath, 'utf8');
    } catch (error) {
        console.error(`Error reading file: ${filePath}`);
        throw error;
    }
}

/**
 * Write content to a file
 */
function writeFile(filePath, content) {
    try {
        fs.writeFileSync(filePath, content, 'utf8');
        console.log(`  Generated: ${path.basename(filePath)}`);
    } catch (error) {
        console.error(`Error writing file: ${filePath}`);
        throw error;
    }
}

/**
 * Recursively resolve CSS @import statements and bundle into single content
 * @param {string} cssContent - CSS content to process
 * @param {string} baseDir - Base directory for resolving relative imports
 * @param {Set} visited - Set of already-visited files to prevent circular imports
 * @returns {string} Bundled CSS content
 */
function bundleCssImports(cssContent, baseDir, visited = new Set()) {
    // Match @import statements with single or double quotes
    const importRegex = /@import\s+['"]([^'"]+)['"]\s*;?/g;
    let result = cssContent;
    let match;
    
    // Collect all imports first to process them in order
    const imports = [];
    while ((match = importRegex.exec(cssContent)) !== null) {
        imports.push({
            fullMatch: match[0],
            importPath: match[1]
        });
    }
    
    // Process each import
    for (const { fullMatch, importPath } of imports) {
        const resolvedPath = path.resolve(baseDir, importPath);
        
        // Skip if already visited (circular import protection)
        if (visited.has(resolvedPath)) {
            result = result.replace(fullMatch, `/* Skipped circular import: ${importPath} */`);
            continue;
        }
        
        try {
            visited.add(resolvedPath);
            let importedContent = readFile(resolvedPath);
            
            // Recursively process imports in the imported file
            const importedDir = path.dirname(resolvedPath);
            importedContent = bundleCssImports(importedContent, importedDir, visited);
            
            // Replace the @import with the actual content
            result = result.replace(fullMatch, `/* === ${importPath} === */\n${importedContent}\n`);
        } catch {
            console.warn(`  Warning: Could not resolve CSS import: ${importPath}`);
            result = result.replace(fullMatch, `/* Failed to import: ${importPath} */`);
        }
    }
    
    return result;
}

/**
 * Bundle all CSS imports into a single styles.bundled.css file
 */
function bundleCss() {
    console.log('  Bundling CSS...');
    
    const mainCssPath = path.join(CSS_DIR, 'styles.css');
    const outputPath = path.join(CSS_DIR, 'styles.bundled.css');
    
    const mainCss = readFile(mainCssPath);
    const bundledCss = bundleCssImports(mainCss, CSS_DIR);
    
    // Add header comment
    const header = `/*
 * Sticky Notes - Bundled CSS
 * Generated by build-site.js
 * Do not edit directly - edit source files in site/css/
 */\n\n`;
    
    writeFile(outputPath, header + bundledCss);
    
    // Calculate size savings
    const originalImports = (mainCss.match(/@import/g) || []).length;
    console.log(`    Bundled ${originalImports} @import statements into single file`);
}

/**
 * Minify JavaScript files
 */
async function minifyJs() {
    console.log('  Minifying JavaScript...');
    
    const jsFiles = ['scripts.js', 'dashboard.js', 'generate-key.js'];
    
    for (const jsFile of jsFiles) {
        const inputPath = path.join(JS_DIR, jsFile);
        const outputPath = path.join(JS_DIR, jsFile.replace('.js', '.min.js'));
        
        // Skip if source file doesn't exist
        if (!fs.existsSync(inputPath)) {
            console.log(`    Skipping ${jsFile} (not found)`);
            continue;
        }
        
        try {
            const code = readFile(inputPath);
            const result = await minify(code, {
                compress: {
                    drop_console: false,  // Keep console for debugging
                    passes: 2
                },
                mangle: true,
                format: {
                    comments: false
                },
                module: true  // Support ES modules
            });
            
            if (result.code) {
                writeFile(outputPath, result.code);
                const savings = ((1 - result.code.length / code.length) * 100).toFixed(1);
                console.log(`    ${jsFile}: ${code.length} -> ${result.code.length} bytes (${savings}% reduction)`);
            }
        } catch (error) {
            console.error(`  Error minifying ${jsFile}:`, error.message);
        }
    }
}

/**
 * Minify CSS files
 */
function minifyCss() {
    console.log('  Minifying CSS...');
    
    const cssFiles = ['dashboard.css', 'generate-key.css', 'styles.bundled.css'];
    const cleanCss = new CleanCSS({
        level: 2,  // Advanced optimizations
        format: false  // No formatting (fully minified)
    });
    
    for (const cssFile of cssFiles) {
        const inputPath = path.join(CSS_DIR, cssFile);
        const outputPath = path.join(CSS_DIR, cssFile.replace('.css', '.min.css'));
        
        // Skip if source file doesn't exist
        if (!fs.existsSync(inputPath)) {
            console.log(`    Skipping ${cssFile} (not found)`);
            continue;
        }
        
        try {
            const code = readFile(inputPath);
            const result = cleanCss.minify(code);
            
            if (result.errors && result.errors.length > 0) {
                console.error(`  Errors in ${cssFile}:`, result.errors);
                continue;
            }
            
            if (result.styles) {
                writeFile(outputPath, result.styles);
                const savings = ((1 - result.styles.length / code.length) * 100).toFixed(1);
                console.log(`    ${cssFile}: ${code.length} -> ${result.styles.length} bytes (${savings}% reduction)`);
            }
        } catch (error) {
            console.error(`  Error minifying ${cssFile}:`, error.message);
        }
    }
}

/**
 * Load all partials from the partials directory
 */
function loadPartials() {
    return {
        head: readFile(path.join(PARTIALS_DIR, 'head.html')),
        header: readFile(path.join(PARTIALS_DIR, 'header.html')),
        footer: readFile(path.join(PARTIALS_DIR, 'footer.html'))
    };
}

/**
 * Get list of template files
 */
function getTemplateFiles() {
    const files = fs.readdirSync(TEMPLATES_DIR);
    return files.filter(file => file.endsWith('.html'));
}

/**
 * Get the minified CSS content (cached)
 */
function getMinifiedCss() {
    if (minifiedCssCache === null) {
        const cssPath = path.join(CSS_DIR, 'styles.bundled.min.css');
        if (fs.existsSync(cssPath)) {
            minifiedCssCache = readFile(cssPath);
        } else {
            console.warn('  Warning: styles.bundled.min.css not found for inlining');
            minifiedCssCache = '';
        }
    }
    return minifiedCssCache;
}

/**
 * Get the minified critical CSS content (cached)
 */
function getMinifiedCriticalCss() {
    if (minifiedCriticalCssCache === null) {
        const cssPath = path.join(CSS_DIR, '_critical.css');
        if (fs.existsSync(cssPath)) {
            const cleanCss = new CleanCSS({ level: 2, format: false });
            const result = cleanCss.minify(readFile(cssPath));
            if (result.styles) {
                // Fix font paths for inlining: url('fonts/...) not url('../fonts/...)
                // because when inlined in index.html, paths are relative to HTML location
                minifiedCriticalCssCache = result.styles.replace(/url\(['"]?\.\.\/fonts\//g, "url('fonts/");
                console.log(`    Critical CSS: ${result.stats.originalSize} -> ${result.styles.length} bytes`);
            } else {
                minifiedCriticalCssCache = '';
            }
        } else {
            console.warn('  Warning: _critical.css not found');
            minifiedCriticalCssCache = '';
        }
    }
    return minifiedCriticalCssCache;
}

/**
 * Process a template by replacing placeholders with partials
 */
function processTemplate(template, partials, options = {}) {
    const { baseUrl = '', inlineCss = false } = options;
    
    let result = template;
    
    // Replace partial placeholders
    result = result.replace(/\{\{HEAD\}\}/g, partials.head);
    result = result.replace(/\{\{HEADER\}\}/g, partials.header);
    result = result.replace(/\{\{FOOTER\}\}/g, partials.footer);
    
    // Replace BASE_URL placeholder
    // For index.html, links should be "#section"
    // For other pages, links should be "index.html" to link back to home
    result = result.replace(/\{\{BASE_URL\}\}/g, baseUrl);
    
    // Inline critical CSS for index.html (fast first paint, full CSS loads async)
    if (inlineCss) {
        const criticalCss = getMinifiedCriticalCss();
        if (criticalCss) {
            // Replace the external stylesheet link with:
            // 1. Inline critical CSS for instant first paint
            // 2. Preload for full CSS (starts download immediately)
            // 3. The full CSS will be loaded by JavaScript after first paint
            const stylesheetRegex = /<link\s+rel="stylesheet"\s+href="css\/styles\.bundled(?:\.min)?\.css"[^>]*>/gi;
            const replacement = `<style>${criticalCss}</style>
    <link rel="preload" href="css/styles.bundled.min.css" as="style">`;
            result = result.replace(stylesheetRegex, replacement);
            console.log(`    Inlined ${(criticalCss.length / 1024).toFixed(1)}KB critical CSS (full CSS loads async)`);
        }
    }
    
    return result;
}

/**
 * Main build function
 */
async function build() {
    console.log('\nBuilding site...\n');
    
    // Bundle CSS (eliminates render-blocking @import waterfall)
    bundleCss();
    
    // Minify CSS (after bundling to include bundled file)
    minifyCss();
    
    // Minify JavaScript
    await minifyJs();
    
    // Load partials
    const partials = loadPartials();
    console.log('  Loaded partials');
    
    // Get template files
    const templateFiles = getTemplateFiles();
    console.log(`  Found ${templateFiles.length} templates\n`);
    
    // Process each template
    templateFiles.forEach(templateFile => {
        const templatePath = path.join(TEMPLATES_DIR, templateFile);
        const outputPath = path.join(SITE_DIR, templateFile);
        
        // Read template
        const template = readFile(templatePath);
        
        // Determine base URL based on file
        // For index.html, use empty string (same page anchors)
        // For other pages, use "index.html" to link back to home
        const isIndex = templateFile === 'index.html';
        const baseUrl = isIndex ? '' : 'index.html';
        
        // Process template
        // Inline CSS only for index.html (landing page optimization)
        const output = processTemplate(template, partials, { 
            baseUrl,
            inlineCss: isIndex  // Inline CSS for index.html only
        });
        
        // Write output
        writeFile(outputPath, output);
    });
    
    console.log('\nSite build complete!\n');
}

// Run build
build();
